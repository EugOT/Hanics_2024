---
title: "Exploratory analysis and Quality Control of P2 mice dataset: Scgn Cre tdTomato"
authors:
  - name: Evgenii O. Tretiakov, PhD
    affiliation: 
      - Department of Molecular Neurosciences, Center for Brain Research, Medical University of Vienna, Vienna A-1090, Austria
    roles: 
      - Conceptualization
      - Formal analysis
      - Data curation
      - Investigation
      - Methodology
      - Software
      - Visualization
      - Resources
      - Writing
    corresponding: true
    orcid: 0000-0001-5920-2190
    email: evgenii.tretiakov@meduniwien.ac.at
  - name: Tibor Harkany, PhD
    affiliation: 
      - Department of Molecular Neurosciences, Center for Brain Research, Medical University of Vienna, Vienna A-1090, Austria
      - Division of Molecular and Cellular Neuroendocrinology, Department of Neuroscience, Biomedicum 7D, Karolinska Institutet, Solna SE-17165, Sweden
    roles: 
      - Conceptualization
      - Funding acquisition
      - Resources
      - Supervision
      - Project administration
      - Writing
    corresponding: true
    orcid: 0000-0002-6637-5900
    email: tibor.harkany@meduniwien.ac.at
date: "`r Sys.Date()`"
output:
  workflowr::wflow_html:
    toc: true
    df-print: paged
    code-fold: true
    fig.width: 14
    fig.height: 12
    fig-format: retina
    fig-responsive: true
    fig-dpi: 300
    embed-resources: true
  pdf:
    colorlinks: true
    fontsize: 12pt
    toc: true
    fig.width: 14
    fig.height: 12
    fig-format: retina
    fig-dpi: 300
execute:
  keep-md: false
  echo: true
  error: false
  message: false
  warning: false
  debug: false
knitr:
  opts_chunk:
    autodep: true
    fig.align: center
    fig.width: 14
    fig.height: 12
bibliography: references.bib
---

```{r}
#| label = "setup",
#| echo = FALSE,
#| include = FALSE
docname <- "01A-eda"
now <- Sys.time()
# Time chunks during knitting
knitr::knit_hooks$set(timeit = function(before) {
  if (before) {
    print(paste("Start:", Sys.time()))
    now <<- Sys.time()
  } else {
    print(paste("Stop:", Sys.time()))
    print(Sys.time() - now)
  }
})

knitr::opts_chunk$set(
  autodep        = TRUE,
  cache          = FALSE,
  cache.path     = paste0("cache/", docname, "/"),
  cache.comments = FALSE,
  cache.lazy     = FALSE,
  dev            = c("png", "pdf"),
  echo           = TRUE,
  error          = FALSE,
  fig.align      = "center",
  fig.width      = 14,
  fig.height     = 12,
  message        = FALSE,
  warning        = FALSE,
  timeit         = TRUE
)
Sys.setenv(RETICULATE_PYTHON = "/opt/python/3.12/bin/python")
# Load tidyverse infrastructure packages
suppressPackageStartupMessages({
  library(here)
  library(knitr)
  library(RColorBrewer)
  library(viridis)
  library(tidyverse)
  library(magrittr)
  library(stringr)
  library(skimr)
  library(future)
  library(zeallot)
  library(kableExtra)
  library(reticulate)
  library(foreach)
  library(doParallel)
})
reticulate::use_condaenv("/opt/python/3.12/bin/python")

suppressPackageStartupMessages({
  library(Seurat)
  library(SeuratWrappers)
  library(SeuratDisk)
  library(sctransform)
  library(glmGamPoi)
  library(clustree)
  library(patchwork)
  library(qs)
  library(scCustomize)
  library(mrtree)
})

options(future.globals.maxSize = 2e11)
options(Seurat.object.assay.version = "v5")

# Set paths
project <- "hanics2024-cortex-tdtomato"
library(here)
library(workflowr)
source(here("code/preprocessing/constants.R"))
source(here(preprocessing_src, "functions.R"))
source(here(preprocessing_src, "utils.R"))
source(here(analysis_src, "analysis.R"))
source(here(analysis_src, "vis.R"))
source(here(preprocessing_src, "data.R"))
source(here(analysis_src, "scDEED.R"))

dir.create(
  here(
    tables_dir,
    docname
  ),
  recursive = TRUE
)

# parallelisation
n_cores <- 12

# set seed
reseed <- 42
set.seed(seed = reseed)

# ggplot2 theme
theme_set(ggmin::theme_powerpoint())
```

We will load and reprocess reference dataset of cortical development
from [@dibellaMolecularLogicCellular2021].

```{r}
# Create a vector with the stage of development for each object
stage_info <- c("E11.5", "E12.5", "E13.5", "E14.5", "E15.5", "E16", "E18.5", "E18", "P1", "P1", "E10", "E17.5", "P4")
```

```{r}
merged_cortex_2 <- SeuratObject::LoadSeuratRds(here::here("data/azimuth_integrated.rds"))
merged_cortex_2$cell_name <- Cells(merged_cortex_2)
merged_cortex_2
```

```{r}
#| label = "read-study-info"
orig_umap <- readr::read_tsv(
  here("data/SCP1290/cluster/cluster_scDevSC.merged.umap.txt"),
  skip = 2,
  col_names = c("cell_name", "UMAP_1", "UMAP_2"),
  col_types = list(col_character(), col_double(), col_double())
)

glimpse(orig_umap)
orig_umap %<>% tibble::column_to_rownames("cell_name")
orig_umap %<>% as.matrix()
orig_tsne <- readr::read_tsv(
  here("data/SCP1290/cluster/cluster_scDevSC.merged.tsne.txt"),
  skip = 2,
  col_names = c("cell_name", "tSNE_1", "tSNE_2"),
  col_types = list(col_character(), col_double(), col_double())
)
glimpse(orig_tsne)
orig_tsne %<>% tibble::column_to_rownames("cell_name")
orig_tsne %<>% as.matrix()
orig_metadata <- readr::read_tsv(here(
  "data/SCP1290/metadata/metaData_scDevSC.txt"
))
orig_metadata %<>% dplyr::rename("cell_name" = "NAME")
orig_metadata_types <- orig_metadata[1, ] |> purrr::simplify()
orig_metadata %<>% dplyr::filter(!cell_name == "TYPE")
glimpse(orig_metadata)

change_column_types <- function(df, types) {
  for (col_name in names(types)) {
    col_type <- types[col_name]

    if (col_type == "character") {
      df[[col_name]] <- as.character(df[[col_name]])
    } else if (col_type == "numeric") {
      df[[col_name]] <- as.numeric(df[[col_name]])
    } else if (col_type == "integer") {
      df[[col_name]] <- as.integer(df[[col_name]])
    } else if (col_type == "logical") {
      df[[col_name]] <- as.logical(df[[col_name]])
    } else if (col_type == "factor") {
      df[[col_name]] <- as.factor(df[[col_name]])
    } else if (col_type == "group") {
      df[[col_name]] <- as.factor(df[[col_name]])
    } else {
      warning(paste("Unknown type:", col_type, "for column", col_name))
    }
  }

  return(df)
}

# Apply the function to the metadata
orig_metadata <- change_column_types(orig_metadata, orig_metadata_types)

# Print the modified metadata
glimpse(orig_metadata)

orig_srt <- Read10X(data.dir = here("data/SCP1290/expression/601ae2f4771a5b0d72588bfb"))

# Convert the log1p normalized matrix to a standard matrix if it's not already
normalized_matrix <- as.matrix(orig_srt)

# Reverse the log1p transformation to get the scaled count matrix
count_matrix <- expm1(normalized_matrix)

# Extract scaling factors
scaling_factors <- orig_metadata[orig_metadata$cell_name == colnames(count_matrix), ]$nCount_RNA / 1e4

# Multiply each column by its scaling factor and round the results (it's not necessary but just to be sure)
scaled_count_matrix <- sweep(count_matrix, 2, scaling_factors, FUN = "*")
scaled_count_matrix <- round(scaled_count_matrix)

# Convert the count matrix to a sparse matrix format (dgCMatrix) as needed
count_matrix_sparse <- as(scaled_count_matrix, "dgCMatrix")

# Create a Seurat object using the recovered count matrix
merged_cortex <- CreateSeuratObject(counts = count_matrix_sparse, meta.data = orig_metadata)

merged_cortex[["umap"]] <- CreateDimReducObject(embeddings = orig_umap, key = "UMAP_", assay = DefaultAssay(merged_cortex))
merged_cortex[["tsne"]] <- CreateDimReducObject(embeddings = orig_tsne, key = "tSNE_", assay = DefaultAssay(merged_cortex))

merged_cortex$stage <- merged_cortex$orig.ident
table(merged_cortex$New_cellType)
Idents(merged_cortex) <- "New_cellType"
merged_cortex <- subset(merged_cortex, idents = c("Doublet", "Low quality cells", "Red blood cells"), invert = TRUE)

merged_cortex <-
  Store_Palette_Seurat(
    seurat_object = merged_cortex,
    palette = rev(brewer.pal(n = 11, name = "Spectral")),
    palette_name = "expr_Colour_Pal"
  )

merged_cortex <- Store_Palette_Seurat(
  seurat_object = merged_cortex,
  palette = ggsci::pal_ucscgb("default")(length(levels(merged_cortex$New_cellType))),
  palette_name = "types_Colour_Pal",
  overwrite = T
)
names(merged_cortex@misc$types_Colour_Pal) <- levels(merged_cortex$New_cellType)

merged_cortex <- Store_Palette_Seurat(
  seurat_object = merged_cortex,
  palette = ggsci::pal_gsea("default")(length(levels(merged_cortex$stage))),
  palette_name = "stage_Colour_Pal",
  overwrite = T
)
names(merged_cortex@misc$stage_Colour_Pal) <- levels(merged_cortex$stage)

genes.embed <- c(
  "Abcd1",
  "Abcd2",
  "Abcd3",
  "Acaa1",
  "Acaa2",
  "Acox1",
  "Agrn",
  "Agt",
  "Alcam",
  "Aldh1a1",
  "Aldh1l1",
  "Aldoc",
  "Angpt1",
  "Apoe",
  "App",
  "Aqp4",
  "Arf1",
  "Bmp7",
  "Bsg",
  "Cacybp",
  "Caf4",
  "Ccl25",
  "Ckb",
  "Cnr1",
  "Cnr2",
  "Col4a5",
  "Cst3",
  "Dagla",
  "Daglb",
  "Decr2",
  "Dcc",
  "Dnm1",
  "Drp1",
  "Ech1",
  "Efna5",
  "Egfr",
  "Enho",
  "Eno1",
  "Faah",
  "Fgf1",
  "Fgfr3",
  "Fis1",
  "Fos",
  "Fth1",
  "Ftl1",
  "Gfap",
  "Gja1",
  "Gli1",
  "Glul",
  "Gnai2",
  "Gnas",
  "H2-K1",
  "Hacd2",
  "Hadhb",
  "Hbegf",
  "Hepacam",
  "Hif1",
  "Htra1",
  "Igsf1",
  "Il18",
  "Il1rapl1",
  "Itgav",
  "Jam2",
  "Lama2",
  "Lamb2",
  "Lcat",
  "Lgi1",
  "Lgi4",
  "Lpcat3",
  "Lrpap1",
  "Lrrc4b",
  "Lxn",
  "Mdk",
  "Mdv1",
  "Mfn1",
  "Mfn2",
  "Mgll",
  "Mief1",
  "Napepld",
  "Ncam1",
  "Ncan",
  "Ndrg2",
  "Nfasc",
  "Nfia",
  "Nlgn3",
  "Nrxn1",
  "Nrxn2",
  "Ntn1",
  "Ntrk3",
  "Opa1",
  "Otp",
  "Pex1",
  "Pex10",
  "Pex12",
  "Pex13",
  "Pex14",
  "Pex16",
  "Pex2",
  "Pex26",
  "Pex3",
  "Pex6",
  "Pkm",
  "Pla2g7",
  "Plcb1",
  "Psap",
  "Ptn",
  "Pygb",
  "Ralyl",
  "Rgma",
  "Rtn4",
  "S100a1",
  "S100a6",
  "S100b",
  "Siah1a",
  "Siah1b",
  "Scd2",
  "Sdc2",
  "Sema6a",
  "Sema6d",
  "Sgcd",
  "Sirpa",
  "Slc1a2",
  "Slc1a3",
  "Slc38a1",
  "Slc4a4",
  "Slc6a11",
  "Slc7a10",
  "Slit1",
  "Slit2",
  "Slitrk2",
  "Sorbs1",
  "Sox9",
  "Sparc",
  "Spon1",
  "Tafa1",
  "Timp3",
  "Tkt",
  "Trpv1",
  "Vcam1",
  "Vegfa"
) %>% .[. %in% rownames(merged_cortex)]

merged_cortex <- FindVariableFeatures(merged_cortex, nfeatures = 5000, verbose = FALSE)
merged_cortex <- NormalizeData(
  merged_cortex,
  features = rownames(merged_cortex),
  verbose = FALSE
)
# Scale data
merged_cortex <- ScaleData(
  merged_cortex,
  features = rownames(merged_cortex),
  verbose = FALSE
)
```

```{r}
# Create DimPlot
p1 <- DimPlot(
  merged_cortex,
  reduction = "umap",
  group.by = c("stage", "New_cellType"),
  combine = FALSE, label.size = 2,
  alpha = 0.7,
  cols = c(merged_cortex@misc$types_Colour_Pal, merged_cortex@misc$stage_Colour_Pal)
)

p2 <- DimPlot(
  merged_cortex,
  reduction = "tsne",
  group.by = c("stage", "New_cellType"),
  combine = FALSE, label.size = 2,
  alpha = 0.7,
  cols = c(merged_cortex@misc$types_Colour_Pal, merged_cortex@misc$stage_Colour_Pal)
)
```

```{r}
#| label = "plot-stages-and-types-all-cells",
#| fig.height = 18,
#| fig.width = 20
wrap_plots(c(p1, p2), ncol = 2, byrow = F)
```

# Introduction

In this document we are going to read in the **RAW** filtered counts
matrix produced by `Cell Ranger`, the **RNA** filtered counts matrix,
where we removed *Ambient RNA* using by `CellBender` at the false
positive rate `FPR=0.001` threshold and results of *Cell Doublets* call
that was done using `Scrublet` then using summary statistics we
determine which of those genes affected the most by our filtering
procedure visualising results by `scCustomize` package and derive
several categories of low quality cells using set of manually adjusted
threshold parameters. Next, we use filtered high quality dataset to
perform initial annotation using `Seurat`, `leidenalg` and `clustree`
packages and deduce stable multi-resolution reconcile clustering tree
with `mrtree` that we need to identify major cell groups for further
analysis.

## Set QC parameters

For the quality control we going to use set of well-known technical
parameters reflecting sources of bias in data such as total mRNA
content, percentage of mitochondrial mRNA content, fraction of molecules
aligned to ribosomal genes, hemoglobine genes transcripts and overall
cell complexity, which is determined as ratio between number of observed
genes per molecule in logarithmic scale. As for doublets, we will use
default `Scrublet` results.

# Combined analysis of scRNA-seq dataset derived from the `r project`

```{r}
#| label = "load"
samples_table <- readr::read_tsv(here("samples.tsv")) %>% arrange(Run)
srr_set <- samples_table$Run

scrublet <-
  purrr::reduce(
    srr_set %>% map(~ read_scrublet(.x, fpr = cb_fpr)),
    bind_rows
  )

options(Seurat.object.assay.version = "v5")

cell_bender_merged <-
  Read_CellBender_h5_Mat(
    file_name = here(
      "cellbender", glue::glue("{srr_set}_output_filtered.h5")
    )
  )

cell_ranger_merged <-
  Read10X_h5(
    filename = here(
      "cellranger_BSF_1105_Mouse_Cortex_SCGN_P02_1/outs",
      "filtered_feature_bc_matrix.h5"
    )
  )



cell_intersect <- intersect(
  x = colnames(x = cell_bender_merged),
  y = colnames(x = cell_ranger_merged)
)

cell_bender_merged <- cell_bender_merged[, cell_intersect]
combined_srt <- CreateSeuratObject(
  counts = cell_bender_merged,
  min.cells = 3,
  min.features = 200
)
cell_names_seurat <- colnames(x = combined_srt)
gene_names_seurat <- rownames(x = combined_srt)
counts <- CreateAssay5Object(
  counts = cell_ranger_merged, min.cells = 0,
  min.features = 0
)
counts <- subset(
  x = counts, cells = Cells(x = combined_srt),
  features = rownames(x = combined_srt)
)
combined_srt[["RAW"]] <- counts
rm(cell_bender_merged, cell_ranger_merged)
combined_srt
combined_srt@assays
Idents(object = combined_srt) <- "WT"
Idents(object = combined_srt, cells = WhichCells(combined_srt@assays$RAW, expression = tdTomato > 0)) <- "Scgn_Cre"
combined_srt$Scgn_tdTomato <- Idents(combined_srt)

plan(sequential)
invisible(gc())
options(future.globals.maxSize = 999999 * 1024^2)
set.seed(seed = reseed)
plan(multisession, workers = n_cores)
```

## Elimination of ambient RNA {.tabset}

### Difference between assays {.unnumbered}

```{r}
#| echo = FALSE
combined_srt <-
  Add_CellBender_Diff(
    seurat_object = combined_srt,
    raw_assay_name = "RAW",
    cell_bender_assay_name = "RNA"
  )

head(combined_srt@meta.data, 5) %>%
  kableExtra::kbl() %>%
  kableExtra::kable_styling(
    bootstrap_options = c(
      "bordered",
      "condensed",
      "responsive",
      "striped"
    )
  )
```

### Median statistics of difference {.unnumbered}

```{r}
#| echo = FALSE
median_stats <-
  Median_Stats(
    seurat_object = combined_srt,
    group_by_var = "Scgn_tdTomato",
    median_var = c("nCount_Diff", "nFeature_Diff")
  )

median_stats %>%
  kableExtra::kbl() %>%
  kableExtra::kable_styling(
    bootstrap_options = c("bordered", "condensed", "responsive", "striped")
  )
```

### Top 20 leakage genes {.unnumbered}

```{r}
#| echo = FALSE
feature_diff <-
  CellBender_Feature_Diff(
    seurat_object = combined_srt,
    raw_assay = "RAW",
    cell_bender_assay = "RNA"
  )

head(feature_diff, 20) %>%
  kableExtra::kbl() %>%
  kableExtra::kable_styling(
    bootstrap_options = c(
      "bordered",
      "condensed",
      "responsive",
      "striped"
    )
  )
```

### Plot feature differences {.unnumbered}

In addition to returning the data.frame it can be useful to visually
examine the changes/trends after running CellBender.

```{r}
#| label = "pl-ambient-correction-qc",
#| echo = FALSE,
#| fig.height = 6,
#| fig.width = 8,
#| fig.align = "center"
CellBender_Diff_Plot(
  feature_diff_df = feature_diff,
  num_labels = 50
)
```

## Quality Control for different types of features {.tabset}

### QC Violin plots

```{r}
#| label = "pl-vln-qc",
#| fig.align = "center",
#| fig.width = 16,
#| fig.asp = 0.618
combined_srt <-
  Store_Palette_Seurat(
    seurat_object = combined_srt,
    palette = rev(brewer.pal(n = 11, name = "RdYlGn")),
    palette_name = "mdat_Colour_Pal"
  )
combined_srt <-
  Store_Palette_Seurat(
    seurat_object = combined_srt,
    palette = rev(brewer.pal(n = 11, name = "Spectral")),
    palette_name = "expr_Colour_Pal"
  )
combined_srt <-
  Store_Palette_Seurat(
    seurat_object = combined_srt,
    palette = qc_palette,
    palette_name = "qc_Colour_Pal"
  )


combined_srt <-
  Add_Mito_Ribo(combined_srt, species = "mouse")
combined_srt[["percent_hb"]] <-
  PercentageFeatureSet(combined_srt, pattern = "^Hb[^(p)]")
combined_srt <-
  Add_Cell_Complexity(combined_srt)

# Visualize QC metrics as a violin plot
p1 <-
  QC_Plots_Complexity(
    combined_srt,
    high_cutoff = high_cutoff_complexity,
    plot_median = TRUE,
    color_seed = reseed,
    ggplot_default_colors = TRUE
  )
p2 <-
  QC_Plots_Genes(
    combined_srt,
    low_cutoff = low_cutoff_gene,
    high_cutoff = high_cutoff_gene,
    plot_median = TRUE,
    plot_title = "Genes per Cell",
    color_seed = reseed,
    ggplot_default_colors = TRUE
  )
p3 <-
  QC_Plots_UMIs(
    combined_srt,
    low_cutoff = low_cutoff_umis,
    high_cutoff = high_cutoff_umis,
    plot_median = TRUE,
    plot_title = "UMIs per Cell",
    color_seed = reseed,
    ggplot_default_colors = TRUE
  )
p4 <-
  QC_Plots_Mito(
    combined_srt,
    high_cutoff = high_cutoff_pc_mt,
    plot_median = TRUE,
    plot_title = "Mito genes % per Cell",
    color_seed = reseed,
    ggplot_default_colors = TRUE
  )
p5 <-
  QC_Plots_Feature(
    combined_srt,
    feature = "percent_ribo",
    high_cutoff = high_cutoff_pc_ribo,
    plot_median = TRUE,
    y_axis_label = "% Ribosomal Genes Counts",
    plot_title = "Ribo genes % per Cell",
    color_seed = reseed,
    ggplot_default_colors = TRUE
  )
p6 <-
  QC_Plots_Feature(
    combined_srt,
    feature = "percent_hb",
    high_cutoff = high_cutoff_pc_hb,
    plot_median = TRUE,
    y_axis_label = "% Hemoglobin Genes Counts",
    plot_title = "Hemoglobin genes % per Cell",
    color_seed = reseed,
    ggplot_default_colors = TRUE
  )

wrap_plots(p1, p2, p3, p4, p5, p6, ncol = 3)
```

### QC Scatter plots

```{r}
#| label = "pl-scatter-qc",
#| fig.width = 11,
#| fig.asp = 0.8
plot1 <-
  QC_Plot_GenevsFeature(
    seurat_object = combined_srt,
    feature1 = "percent_mito",
    low_cutoff_gene = low_cutoff_gene,
    high_cutoff_gene = high_cutoff_gene,
    high_cutoff_feature = high_cutoff_pc_mt,
    color_seed = reseed,
    ggplot_default_colors = TRUE,
    pt.size = 0.3,
    shuffle_seed = reseed
  ) &
    scale_y_log10()
plot2 <-
  QC_Plot_UMIvsGene(
    seurat_object = combined_srt,
    low_cutoff_gene = low_cutoff_gene,
    high_cutoff_gene = high_cutoff_gene,
    low_cutoff_UMI = low_cutoff_umis,
    high_cutoff_UMI = high_cutoff_umis,
    color_seed = reseed,
    ggplot_default_colors = TRUE,
    pt.size = 0.3,
    shuffle_seed = reseed
  ) &
    scale_x_log10() & scale_y_log10()
plot3 <-
  QC_Plot_GenevsFeature(
    seurat_object = combined_srt,
    feature1 = "percent_ribo",
    low_cutoff_gene = low_cutoff_gene,
    high_cutoff_gene = high_cutoff_gene,
    high_cutoff_feature = high_cutoff_pc_ribo,
    color_seed = reseed,
    ggplot_default_colors = TRUE,
    pt.size = 0.3,
    shuffle_seed = reseed
  ) &
    scale_y_log10()
plot4 <-
  FeatureScatter(
    combined_srt,
    feature1 = "percent_ribo",
    feature2 = "percent_mito",
    shuffle = TRUE,
    pt.size = 0.3,
    seed = reseed
  ) +
  geom_hline(yintercept = high_cutoff_pc_mt, color = "red", linetype = "dashed") +
  geom_vline(xintercept = high_cutoff_pc_ribo, color = "blue", linetype = "dashed")
(plot1 + plot2) / (plot3 + plot4)
```

### QC Scatter mito-threshold

```{r}
#| label = "pl-scatter-qc-comb-mito",
#| fig.height = 7,
#| fig.width = 13,
#| fig.align = "center"
QC_Plot_UMIvsGene(
  seurat_object = combined_srt,
  meta_gradient_name = "percent_mito",
  low_cutoff_gene = low_cutoff_gene,
  high_cutoff_gene = high_cutoff_gene,
  low_cutoff_UMI = low_cutoff_umis,
  high_cutoff_UMI = high_cutoff_umis,
  meta_gradient_low_cutoff = high_cutoff_pc_mt,
  meta_gradient_color = combined_srt@misc$mdat_Colour_Pal,
  combination = TRUE,
  color_seed = reseed,
  ggplot_default_colors = TRUE,
  pt.size = 1,
  shuffle_seed = reseed
) &
  scale_x_log10() & scale_y_log10()
```

### QC Scatter ribo-threshold

```{r}
#| label = "pl-scatter-qc-comb-ribo",
#| fig.height = 7,
#| fig.width = 13,
#| fig.align = "center"
QC_Plot_UMIvsGene(
  seurat_object = combined_srt,
  meta_gradient_name = "percent_ribo",
  low_cutoff_gene = low_cutoff_gene,
  high_cutoff_gene = high_cutoff_gene,
  low_cutoff_UMI = low_cutoff_umis,
  high_cutoff_UMI = high_cutoff_umis,
  meta_gradient_low_cutoff = high_cutoff_pc_ribo,
  meta_gradient_color = combined_srt@misc$mdat_Colour_Pal,
  combination = TRUE,
  color_seed = reseed,
  ggplot_default_colors = TRUE,
  pt.size = 1,
  shuffle_seed = reseed
) &
  scale_x_log10() & scale_y_log10()
```

### QC Scatter complexity-threshold

```{r}
#| label = "pl-scatter-qc-comb-complexity",
#| fig.height = 7,
#| fig.width = 13,
#| fig.align = "center"
QC_Plot_UMIvsGene(
  seurat_object = combined_srt,
  meta_gradient_name = "log10GenesPerUMI",
  low_cutoff_gene = low_cutoff_gene,
  high_cutoff_gene = high_cutoff_gene,
  low_cutoff_UMI = low_cutoff_umis,
  high_cutoff_UMI = high_cutoff_umis,
  meta_gradient_low_cutoff = high_cutoff_complexity,
  meta_gradient_color = combined_srt@misc$mdat_Colour_Pal,
  combination = TRUE,
  color_seed = reseed,
  ggplot_default_colors = TRUE,
  pt.size = 1,
  shuffle_seed = reseed
) &
  scale_x_log10() & scale_y_log10()
```

### QC Scatter doublets by sample

```{r}
#| label = "pl-scatter-doublets-log-prob",
#| echo = FALSE,
#| fig.height = 12,
#| fig.width = 16,
#| fig.align = "center"
combined_srt$barcode <- colnames(combined_srt)
scrublet <- scrublet |>
  dplyr::filter(barcode %in% colnames(combined_srt)) |>
  as.data.frame()
rownames(scrublet) <- scrublet$barcode
scrublet <- scrublet[colnames(combined_srt), ]
if (any(sum(combined_srt$barcode %in% scrublet$barcode))) {
  combined_srt <- AddMetaData(
    object = combined_srt,
    metadata = scrublet
  )
  combined_srt$QC <-
    combined_srt@meta.data %>%
    mutate(QC = if_else(
      condition = (predicted_doublet | doublet_score >= 0.95),
      true = "Doublet",
      false = "Pass"
    )) |>
    pull(QC)
  FeatureScatter_scCustom(
    seurat_object = combined_srt,
    feature1 = "nFeature_RNA",
    feature2 = "doublet_score",
    colors_use = combined_srt@misc$qc_Colour_Pal,
    split.by = "orig.ident",
    group.by = "QC",
    num_columns = if_else(
      length(unique(combined_srt$orig.ident)) >= 3,
      3,
      length(unique(combined_srt$orig.ident))
    ),
    shuffle = TRUE,
    pt.size = 4,
    seed = reseed
  ) &
    scale_x_log10() &
    guides(colour = ggh4x::guide_stringlegend(face = "bold", spacing = 15))
} else {
  combined_srt$QC <- "Pass"
}
Idents(combined_srt) <- combined_srt$QC
```

### QC Scatter doublets-threshold

```{r}
#| label = "pl-scatter-qc-comb-doublets",
#| fig.height = 7,
#| fig.width = 13,
#| fig.align = "center"
QC_Plot_UMIvsGene(
  seurat_object = combined_srt,
  meta_gradient_name = "doublet_score",
  low_cutoff_gene = low_cutoff_gene,
  high_cutoff_gene = high_cutoff_gene,
  low_cutoff_UMI = low_cutoff_umis,
  high_cutoff_UMI = high_cutoff_umis,
  meta_gradient_low_cutoff = high_cutoff_doublet_score,
  meta_gradient_color = combined_srt@misc$mdat_Colour_Pal,
  combination = TRUE,
  color_seed = reseed,
  ggplot_default_colors = TRUE,
  pt.size = 1,
  shuffle_seed = reseed
) &
  scale_x_log10() & scale_y_log10()
```

# Apply QC thresholds to derive categories

```{r}
combined_srt$QC <-
  ifelse(
    combined_srt@meta.data$log10GenesPerUMI < high_cutoff_complexity &
      combined_srt@meta.data$QC == "Pass",
    "Low_Complexity",
    combined_srt@meta.data$QC
  )
combined_srt$QC <-
  ifelse(
    combined_srt@meta.data$log10GenesPerUMI < high_cutoff_complexity &
      combined_srt@meta.data$QC != "Pass" &
      combined_srt@meta.data$QC != "Low_Complexity",
    paste("Low_Complexity", combined_srt@meta.data$QC, sep = ","),
    combined_srt@meta.data$QC
  )
combined_srt$QC <-
  ifelse(
    combined_srt@meta.data$nFeature_RNA < low_cutoff_gene &
      combined_srt@meta.data$QC == "Pass",
    "Low_nFeature",
    combined_srt@meta.data$QC
  )
combined_srt$QC <-
  ifelse(
    combined_srt@meta.data$nFeature_RNA < low_cutoff_gene &
      combined_srt@meta.data$QC != "Pass" &
      combined_srt@meta.data$QC != "Low_nFeature",
    paste("Low_nFeature", combined_srt@meta.data$QC, sep = ","),
    combined_srt@meta.data$QC
  )
combined_srt$QC <-
  ifelse(
    combined_srt@meta.data$percent_mito > high_cutoff_pc_mt &
      combined_srt@meta.data$QC == "Pass",
    "High_MT",
    combined_srt@meta.data$QC
  )
combined_srt$QC <-
  ifelse(
    combined_srt@meta.data$percent_mito > high_cutoff_pc_mt &
      combined_srt@meta.data$QC != "Pass" &
      combined_srt@meta.data$QC != "High_MT",
    paste("High_MT", combined_srt@meta.data$QC, sep = ","),
    combined_srt@meta.data$QC
  )
combined_srt$QC <-
  ifelse(
    combined_srt@meta.data$nCount_RNA > high_cutoff_umis &
      combined_srt@meta.data$QC == "Pass",
    "High_UMIs",
    combined_srt@meta.data$QC
  )
combined_srt$QC <-
  ifelse(
    combined_srt@meta.data$nCount_RNA > high_cutoff_umis &
      combined_srt@meta.data$QC != "Pass" &
      combined_srt@meta.data$QC != "High_UMIs",
    paste("High_UMIs", combined_srt@meta.data$QC, sep = ","),
    combined_srt@meta.data$QC
  )
combined_srt$QC <-
  ifelse(
    combined_srt@meta.data$percent_ribo > high_cutoff_pc_ribo &
      combined_srt@meta.data$QC == "Pass",
    "High_Ribo",
    combined_srt@meta.data$QC
  )
combined_srt$QC <-
  ifelse(
    combined_srt@meta.data$percent_ribo > high_cutoff_pc_ribo &
      combined_srt@meta.data$QC != "Pass" &
      combined_srt@meta.data$QC != "High_Ribo",
    paste("High_Ribo", combined_srt@meta.data$QC, sep = ","),
    combined_srt@meta.data$QC
  )
combined_srt$QC <-
  ifelse(
    combined_srt@meta.data$percent_hb > high_cutoff_pc_hb &
      combined_srt@meta.data$QC == "Pass",
    "High_Hgb",
    combined_srt@meta.data$QC
  )
combined_srt$QC <-
  ifelse(
    combined_srt@meta.data$percent_hb > high_cutoff_pc_hb &
      combined_srt@meta.data$QC != "Pass" &
      combined_srt@meta.data$QC != "High_Hgb",
    paste("High_Hgb", combined_srt@meta.data$QC, sep = ","),
    combined_srt@meta.data$QC
  )
table(combined_srt$QC)
```

Let's see how Scrublet score match distributed across our categories

```{r}
#| label = "pl-scatter-doublets-log-prob-qc-categories",
#| echo = FALSE,
#| fig.height = 14,
#| fig.width = 17,
#| fig.align = "center"
FeatureScatter_scCustom(
  seurat_object = combined_srt,
  feature1 = "nFeature_RNA",
  feature2 = "doublet_score",
  colors_use = combined_srt@misc$qc_Colour_Pal,
  split.by = "orig.ident",
  group.by = "QC",
  num_columns = if_else(
    length(unique(combined_srt$orig.ident)) >= 3,
    3,
    length(unique(combined_srt$orig.ident))
  ),
  shuffle = TRUE,
  pt.size = 3,
  seed = reseed
) &
  scale_x_log10() &
  guides(colour = ggh4x::guide_stringlegend(face = "bold", spacing = 15))
```

### subset tdTomato

```{r}
Idents(combined_srt) <- combined_srt$QC
DefaultAssay(combined_srt) <- "RNA"
cells <- WhichCells(combined_srt, idents = "Pass")
combined_srt <- subset(combined_srt, idents = "Pass")
Idents(combined_srt) <- combined_srt$Scgn_tdTomato
```

## Visualize QC metrics as a violin plot again after subset

```{r}
#| label = "pl-vln-qc-subset",
#| fig.align = "center",
#| fig.width = 9,
#| fig.asp = 0.618
p1 <-
  QC_Plots_Complexity(
    seurat_object = combined_srt,
    plot_median = TRUE,
    color_seed = reseed,
    ggplot_default_colors = TRUE
  )
p2 <-
  QC_Plots_Genes(
    seurat_object = combined_srt,
    low_cutoff = low_cutoff_gene,
    high_cutoff = high_cutoff_gene,
    plot_median = TRUE,
    plot_title = "Genes per Cell",
    color_seed = reseed,
    ggplot_default_colors = TRUE
  )
p3 <-
  QC_Plots_UMIs(
    seurat_object = combined_srt,
    low_cutoff = low_cutoff_umis,
    high_cutoff = high_cutoff_umis,
    plot_median = TRUE,
    plot_title = "UMIs per Cell",
    color_seed = reseed,
    ggplot_default_colors = TRUE
  )
p4 <-
  QC_Plots_Mito(
    seurat_object = combined_srt,
    high_cutoff = high_cutoff_pc_mt,
    plot_median = TRUE,
    plot_title = "Mito genes % per Cell",
    color_seed = reseed,
    ggplot_default_colors = TRUE
  )
p5 <-
  QC_Plots_Feature(
    seurat_object = combined_srt,
    feature = "percent_ribo",
    high_cutoff = high_cutoff_pc_ribo,
    plot_median = TRUE,
    y_axis_label = "% Ribosomal Genes Counts",
    plot_title = "Ribo genes % per Cell",
    color_seed = reseed,
    ggplot_default_colors = TRUE
  )
p6 <-
  QC_Plots_Feature(
    seurat_object = combined_srt,
    feature = "percent_hb",
    high_cutoff = high_cutoff_pc_hb,
    plot_median = TRUE,
    y_axis_label = "% Hemoglobin Genes Counts",
    plot_title = "Hemoglobin genes % per Cell",
    color_seed = reseed,
    ggplot_default_colors = TRUE
  )

wrap_plots(p1, p2, p3, p4, p5, p6, ncol = 3)
```

# Reevaluate after subsetting low-quality cells

# Apply SCTransform pipeline

```{r}
#| label = "normalisation"
plan("sequential")
invisible(gc())
set.seed(reseed)
plan(multisession, workers = n_cores)


# normalize and run dimensionality reduction on control dataset
npcs <- 100
metadata <- combined_srt@meta.data
rownames(metadata) <- colnames(combined_srt)
combined_srt <-
  SCTransform(
    combined_srt,
    vst.flavor = "v2",
    ncells = ncol(combined_srt),
    variable.features.n = 5000,
    vars.to.regress = c(
      "log10GenesPerUMI",
      "percent_mito_ribo"
    ),
    return.only.var.genes = FALSE,
    seed.use = reseed,
    verbose = FALSE
  )
hvg <- VariableFeatures(combined_srt)
var_regex <- "^Hla-|^Ig[hjkl]|^Rna|^mt-|^Rp[sl]|^Hb[^(p)]|^Gm"
hvg <- hvg[str_detect(pattern = var_regex, string = hvg, negate = TRUE)]

keep_genes <-
  c("tdTomato", "Scgn", gene_int, hvg) %>%
  unique() %>%
  .[!. %in% housekeeping_mouse] %>%
  .[!. %in% sex_genes] %>%
  .[!. %in% stress_genes]
glimpse(keep_genes)

out_of_hvg <- keep_genes[!keep_genes %in% hvg]
kable_material(
  kable(out_of_hvg, "html"),
  bootstrap_options = c(
    "bordered",
    "condensed",
    "responsive",
    "striped"
  ),
  position = "left",
  font_size = 14
)

hvg <- hvg[hvg %in% keep_genes]

combined_srt <- combined_srt %>%
  RunPCA(features = keep_genes, npcs = npcs, seed.use = reseed, verbose = FALSE)
```

```{r}
#| label = "update-gene-lists-sct"
source(here(src_dir, "genes.R"))
npr %<>% .[. %in% rownames(GetAssayData(combined_srt, slot = "scale.data"))]
np %<>% .[. %in% rownames(GetAssayData(combined_srt, slot = "scale.data"))]
neurotrans %<>% .[. %in% rownames(GetAssayData(combined_srt, slot = "scale.data"))]
glut %<>% .[. %in% rownames(GetAssayData(combined_srt, slot = "scale.data"))]
gaba %<>% .[. %in% rownames(GetAssayData(combined_srt, slot = "scale.data"))]
dopam %<>% .[. %in% rownames(GetAssayData(combined_srt, slot = "scale.data"))]
ach %<>% .[. %in% rownames(GetAssayData(combined_srt, slot = "scale.data"))]
genes.embed %<>% .[. %in% rownames(GetAssayData(combined_srt, slot = "scale.data"))]
```

## Derive dimensional reductions and clusters of filtered dataset {.tabset}

```{r}
#| label = "pca-genes"
print(combined_srt[["pca"]], dims = 1:5, nfeatures = 5)
```

### PCA gene loadings

```{r}
#| label = "pl-pca-loadings",
#| fig.asp = 1.618,
#| fig.width = 8
VizDimLoadings(combined_srt, dims = 1:4, reduction = "pca")
```

### Heatmap

```{r}
#| label = "pl-pca-heatmap",
#| fig.height = 8,
#| fig.width = 6
DimHeatmap(combined_srt, dims = 1:15, cells = 500, balanced = TRUE)
```

### Elbow

```{r}
#| label = "pl-elbow-pca",
#| fig.height = 4,
#| fig.width = 6
ElbowPlot(combined_srt, ndims = npcs)
```

```{r}
#| label = "umap"
plan("sequential")
invisible(gc())
set.seed(reseed)
plan(multicore, workers = n_cores)

selected_pcs <-
  seq_len(50)

if (!file.exists(here(data_dir, glue::glue("{project}-init/{project}-init-umap-search.Rds")))) {
  umap_example <- scDEED(
    input_data = combined_srt,
    K = length(selected_pcs),
    n_neighbors = seq(from = 15, to = 35, by = 10),
    min.dist = c(0.01, 0.05, 0.1, 0.25, 0.5, 0.8),
    reduction.method = "umap",
    default_assay = "SCT"
  )

  dir.create(here(data_dir, sprintf("%s-init", project)))
  readr::write_rds(
    x = umap_example,
    file = here(data_dir, glue::glue("{project}-init/{project}-init-umap-search.Rds"))
  )
} else {
  umap_example <-
    read_rds(here(data_dir, glue::glue("{project}-init/{project}-init-umap-search.Rds")))
}
```

```{r}
#| label = "t-sne"
plan(sequential)
invisible(gc())
set.seed(seed = reseed)
plan(multisession, workers = n_cores)
registerDoParallel(cores = n_cores)


if (!file.exists(here(data_dir, glue::glue("{project}-init/{project}-init-tsne-search.Rds")))) {
  tsne_example <- scDEED(
    combined_srt,
    K = length(selected_pcs),
    reduction.method = "tsne",
    default_assay = "SCT"
  )

  dir.create(here(data_dir, sprintf("%s-init", project)))
  readr::write_rds(
    x = tsne_example,
    file = here(data_dir, glue::glue("{project}-init/{project}-init-tsne-search.Rds"))
  )
} else {
  tsne_example <-
    read_rds(here(data_dir, glue::glue("{project}-init/{project}-init-tsne-search.Rds")))
}
```

```{r}
#| label = "pl-unsupervised"
plan(sequential)
invisible(gc())
set.seed(seed = reseed)
plan(multisession, workers = n_cores)

combined_srt <-
  combined_srt |>
  FindNeighbors(
    dims = selected_pcs,
    k.param = umap_example$num_dubious |>
      dplyr::slice_min(order_by = number_dubious_cells, n = 1) |>
      pull(n_neighbors),
    annoy.metric = "euclidean",
    n.trees = 100,
    verbose = FALSE
  ) |>
  RunUMAP(
    dims = selected_pcs,
    reduction.name = "umap",
    reduction.key = "UMAP_",
    return.model = FALSE,
    umap.method = "uwot",
    n.epochs = 1000L,
    n.neighbors = umap_example$num_dubious |>
      dplyr::slice_min(order_by = number_dubious_cells, n = 1) |>
      pull(n_neighbors),
    min.dist = umap_example$num_dubious |>
      dplyr::slice_min(order_by = number_dubious_cells, n = 1) |>
      pull(min.dist),
    seed.use = reseed,
    verbose = FALSE
  )

combined_srt <-
  RunTSNE(
    combined_srt,
    reduction = "pca",
    dims = selected_pcs,
    seed.use = reseed,
    reduction.name = "tsne",
    reduction.key = "tSNE_",
    perplexity = tsne_example$num_dubious |>
      dplyr::slice_min(order_by = number_dubious_cells, n = 1) |>
      pull(perplexity) |> as.integer()
  )

pacmap <- reticulate::import("pacmap")
# Initialize PaCMAP instance
reducer <- pacmap$PaCMAP(
  n_components = 2L,
  MN_ratio = 0.5,
  FP_ratio = 2.0,
  apply_pca = FALSE
)

# Perform dimensionality Reduction
pacmap_embedding <-
  reducer$fit_transform(Embeddings(combined_srt[["pca"]])[, selected_pcs])

colnames(pacmap_embedding) <- paste0("PaCMAP_", 1:2)
rownames(pacmap_embedding) <- colnames(combined_srt)
# We will now store this as a custom dimensional reduction called 'pacmap'
combined_srt[["pacmap"]] <-
  CreateDimReducObject(
    embeddings = pacmap_embedding,
    key = "PaCMAP_",
    assay = DefaultAssay(combined_srt)
  )
```

## Mitochondrial genes expression {.tabset}

### UMAP

```{r}
#| label = "plt-UMAP-mt",
#| fig.align = "center",
#| fig.asp = 0.618,
#| fig.width = 5
FeaturePlot_scCustom(
  combined_srt,
  features = "percent_mito",
  label.size = 4,
  repel = TRUE,
  pt.size = 1,
  label = TRUE,
  colors_use = combined_srt@misc$mdat_Colour_Pal,
  order = TRUE,
  alpha_na_exp = 0.1,
  alpha_exp = 0.45
) &
  theme(plot.title = element_text(size = 16))
```

### PaCMAP

```{r}
#| label = "plt-PaCMAP-mt",
#| fig.align = "center",
#| fig.asp = 0.618,
#| fig.width = 5
FeaturePlot_scCustom(
  combined_srt,
  features = "percent_mito",
  reduction = "pacmap",
  label.size = 4,
  repel = TRUE,
  pt.size = 1,
  label = TRUE,
  colors_use = combined_srt@misc$mdat_Colour_Pal,
  order = TRUE,
  alpha_na_exp = 0.1,
  alpha_exp = 0.45
) &
  theme(plot.title = element_text(size = 16))
```

### tSNE

```{r}
#| label = "plt-tSNE-mt",
#| fig.align = "center",
#| fig.asp = 0.618,
#| fig.width = 5
FeaturePlot_scCustom(
  combined_srt,
  features = "percent_mito",
  reduction = "tsne",
  label.size = 4,
  repel = TRUE,
  pt.size = 1,
  label = TRUE,
  colors_use = combined_srt@misc$mdat_Colour_Pal,
  order = TRUE,
  alpha_na_exp = 0.1,
  alpha_exp = 0.45
) &
  theme(plot.title = element_text(size = 16))
```

### Violin

```{r}
#| label = "plt-vln-mt",
#| fig.align = "center",
#| fig.asp = 0.618,
#| fig.width = 5
QC_Plots_Mito(
  combined_srt,
  high_cutoff = high_cutoff_pc_mt,
  plot_median = TRUE,
  plot_title = "Mito genes % per Cell",
  color_seed = reseed,
  ggplot_default_colors = TRUE
)
```

## Ribosomal genes expression {.tabset}

### UMAP

```{r}
#| label = "plt-UMAP-rb",
#| fig.align = "center",
#| fig.asp = 0.618,
#| fig.width = 5
FeaturePlot_scCustom(
  combined_srt,
  features = "percent_ribo",
  label.size = 4,
  repel = TRUE,
  pt.size = 1,
  label = TRUE,
  colors_use = combined_srt@misc$mdat_Colour_Pal,
  order = TRUE,
  alpha_na_exp = 0.1,
  alpha_exp = 0.45
) &
  theme(plot.title = element_text(size = 16))
```

### PaCMAP

```{r}
#| label = "plt-PaCMAP-rb",
#| fig.align = "center",
#| fig.asp = 0.618,
#| fig.width = 5
FeaturePlot_scCustom(
  combined_srt,
  features = "percent_ribo",
  reduction = "pacmap",
  label.size = 4,
  repel = TRUE,
  pt.size = 1,
  label = TRUE,
  colors_use = combined_srt@misc$mdat_Colour_Pal,
  order = TRUE,
  alpha_na_exp = 0.1,
  alpha_exp = 0.45
) &
  theme(plot.title = element_text(size = 16))
```

### tSNE

```{r}
#| label = "plt-tSNE-rb",
#| fig.align = "center",
#| fig.asp = 0.618,
#| fig.width = 5
FeaturePlot_scCustom(
  combined_srt,
  features = "percent_ribo",
  reduction = "tsne",
  label.size = 4,
  repel = TRUE,
  pt.size = 1,
  label = TRUE,
  colors_use = combined_srt@misc$mdat_Colour_Pal,
  order = TRUE,
  alpha_na_exp = 0.1,
  alpha_exp = 0.45
) &
  theme(plot.title = element_text(size = 16))
```

### Violin

```{r}
#| label = "plt-vln-rb",
#| fig.align = "center",
#| fig.asp = 0.618,
#| fig.width = 5
QC_Plots_Feature(
  combined_srt,
  feature = "percent_ribo",
  plot_median = TRUE,
  high_cutoff = high_cutoff_pc_ribo,
  y_axis_label = "% Ribosomal Genes Counts",
  plot_title = "Ribo genes % per Cell",
  color_seed = reseed,
  ggplot_default_colors = TRUE
)
```

## Total UMIs and Genes

```{r}
#| label = "plt-vln-genes-umis",
#| fig.align = "center",
#| fig.asp = 0.618,
#| fig.width = 5
p1 <-
  QC_Plots_Genes(
    combined_srt,
    low_cutoff = low_cutoff_gene,
    high_cutoff = high_cutoff_gene,
    plot_median = TRUE,
    plot_title = "Genes per Cell",
    color_seed = reseed,
    ggplot_default_colors = TRUE
  )
p2 <-
  QC_Plots_UMIs(
    combined_srt,
    low_cutoff = low_cutoff_umis,
    high_cutoff = high_cutoff_umis,
    plot_median = TRUE,
    plot_title = "UMIs per Cell",
    color_seed = reseed,
    ggplot_default_colors = TRUE
  )
p1 | p2
```

```{r}
plan("sequential")
invisible(gc())
set.seed(reseed)
plan(multicore, workers = n_cores)


combined_srt <-
  CellCycleScoring(
    combined_srt,
    s.features = str_to_sentence(
      cc.genes.updated.2019$s.genes
    ) %>%
      .[. %in% rownames(combined_srt)],
    g2m.features = str_to_sentence(
      cc.genes.updated.2019$g2m.genes
    ) %>%
      .[. %in% rownames(combined_srt)],
    assay = "SCT"
  )
table(combined_srt[[]]$Phase)
```

## Cell Cycle genes expression {.tabset}

### UMAP

```{r}
#| label = "plt-UMAP-cell-cycle",
#| fig.align = "center",
#| fig.width = 9,
#| fig.asp = 0.309
FeaturePlot_scCustom(
  combined_srt,
  features = c("S.Score", "G2M.Score"),
  reduction = "umap",
  label.size = 4,
  repel = TRUE,
  pt.size = 1,
  label = TRUE,
  colors_use = combined_srt@misc$mdat_Colour_Pal,
  na_cutoff = NA,
  order = TRUE,
  alpha_na_exp = 0.1,
  alpha_exp = 0.45
) &
  theme(plot.title = element_text(size = 16))
```

### PaCMAP

```{r}
#| label = "plt-PaCMAP-cell-cycle",
#| fig.align = "center",
#| fig.width = 9,
#| fig.asp = 0.309
FeaturePlot_scCustom(
  combined_srt,
  features = c("S.Score", "G2M.Score"),
  reduction = "pacmap",
  label.size = 4,
  repel = TRUE,
  pt.size = 1,
  label = TRUE,
  colors_use = combined_srt@misc$mdat_Colour_Pal,
  na_cutoff = NA,
  order = TRUE,
  alpha_na_exp = 0.1,
  alpha_exp = 0.45
) &
  theme(plot.title = element_text(size = 16))
```

### tSNE

```{r}
#| label = "plt-tSNE-cell-cycle",
#| fig.align = "center",
#| fig.width = 9,
#| fig.asp = 0.309
FeaturePlot_scCustom(
  combined_srt,
  features = c("S.Score", "G2M.Score"),
  reduction = "tsne",
  label.size = 4,
  repel = TRUE,
  pt.size = 1,
  label = TRUE,
  colors_use = combined_srt@misc$mdat_Colour_Pal,
  na_cutoff = NA,
  order = TRUE,
  alpha_na_exp = 0.1,
  alpha_exp = 0.45
) &
  theme(plot.title = element_text(size = 16))
```

### Violin

```{r}
#| label = "plt-vln-cell-cycle",
#| fig.align = "center",
#| fig.width = 8,
#| fig.asp = 0.618
plt_s_phase <- VlnPlot_scCustom(seurat_object = combined_srt, features = c("S.Score"), plot_median = TRUE) & NoLegend()
plt_g2m_phase <- VlnPlot_scCustom(seurat_object = combined_srt, features = c("G2M.Score"), plot_median = TRUE) & NoLegend()

(plt_s_phase | plt_g2m_phase)
```

## Plot by source after clean up {.tabset}

### UMAP

```{r}
#| label = "pl-UMAP-gen",
#| fig.align = "center",
#| fig.width = 9,
#| fig.asp = 0.618
pl_emb_comb_batch <- DimPlot_scCustom(
  seurat_object = combined_srt,
  reduction = "umap",
  group.by = "Scgn_tdTomato",
  pt.size = 1,
  ggplot_default_colors = TRUE,
  color_seed = reseed,
  shuffle = TRUE,
  seed = reseed,
  repel = TRUE,
  label = TRUE,
  label.size = 5
) + NoLegend()
pl_emb_comb_batch
```

### PaCMAP

```{r}
#| label = "pl-PaCMAP-gen",
#| fig.align = "center",
#| fig.width = 9,
#| fig.asp = 0.618
pl_emb_comb_batch <- DimPlot_scCustom(
  seurat_object = combined_srt,
  reduction = "pacmap",
  group.by = "Scgn_tdTomato",
  pt.size = 1,
  ggplot_default_colors = TRUE,
  color_seed = reseed,
  shuffle = TRUE,
  seed = reseed,
  repel = TRUE,
  label = TRUE,
  label.size = 5
) + NoLegend()
pl_emb_comb_batch
```

### tSNE

```{r}
#| label = "pl-tSNE-gen",
#| fig.align = "center",
#| fig.width = 9,
#| fig.asp = 0.618
pl_emb_comb_batch <- DimPlot_scCustom(
  seurat_object = combined_srt,
  reduction = "tsne",
  group.by = "Scgn_tdTomato",
  pt.size = 1,
  ggplot_default_colors = TRUE,
  color_seed = reseed,
  shuffle = TRUE,
  seed = reseed,
  repel = TRUE,
  label = TRUE,
  label.size = 5
) + NoLegend()
pl_emb_comb_batch
```

## Clustering tree {.tabset}

### Standard

Coloured by clustering resolution.

```{r}
#| label = "pl-clustree",
#| fig.width = 10,
#| fig.asp = 1.618
plan("sequential")
invisible(gc())
set.seed(reseed)
plan(multicore, workers = n_cores)


metadata <- combined_srt@meta.data
rownames(metadata) <- colnames(combined_srt)

resolutions <-
  modularity_event_sampling(
    A = combined_srt@graphs$SCT_snn,
    n.res = 10,
    gamma.min = 0.2,
    gamma.max = 2.000001
  ) # sample based on the similarity matrix

plan("sequential")
invisible(gc())
set.seed(reseed)
plan(multicore, workers = n_cores)


# clustering using Suerat
combined_srt <- combined_srt %>%
  FindClusters(
    algorithm = "leiden",
    partition.type = "ModularityVertexPartition",
    method = "igraph",
    n.iter = -1,
    resolution = resolutions,
    random.seed = reseed,
    verbose = FALSE
  )
ref_labels <- combined_srt$seurat_clusters

# initial cluster tree from Seurat flat clustering
plot_clustree(
  labelmat = combined_srt@meta.data,
  prefix = "SCT_snn_res.",
  ref_labels = ref_labels,
  plot.ref = FALSE,
  layout = "sugiyama",
  use_core_edges = FALSE
)
```

### Stability

Coloured by the SC3 stability metric.

```{r}
#| label = "clustree-stability"
plot_clustree(
  labelmat = combined_srt@meta.data,
  prefix = "SCT_snn_res.",
  node_colour = "sc3_stability",
  plot.ref = FALSE,
  layout = "sugiyama",
  use_core_edges = FALSE
)
```

## Reconcile clustering tree {.tabset}

### MRTree

```{r}
#| label = "pl-mrtree",
#| fig.height = 6,
#| fig.width = 11,
#| echo = TRUE,
#| include = FALSE
out <- mrtree(
  combined_srt,
  prefix = "SCT_snn_res.",
  n.cores = n_cores,
  consensus = FALSE,
  sample.weighted = TRUE,
  augment.path = FALSE,
  verbose = FALSE
)
# weight per sample is encoraged if the classes are imbalanced
```

### Adjusted Multiresolution Rand Index (AMRI)

```{r}
#| label = "pl-clustering-amri",
#| fig.align = "center",
#| fig.width = 4,
#| fig.asp = 0.618
# Adjusted Multiresolution Rand Index (AMRI)
ks_flat <- apply(
  out$labelmat.flat,
  2,
  FUN = function(x) {
    length(unique(x))
  }
)
ks_mrtree <- apply(
  out$labelmat.mrtree,
  2,
  FUN = function(x) {
    length(unique(x))
  }
)
amri_flat <- sapply(seq_len(ncol(out$labelmat.flat)), function(i) {
  AMRI(out$labelmat.flat[, i], ref_labels)$amri
})
amri_flat <- aggregate(amri_flat, by = list(k = ks_flat), FUN = mean)
amri_recon <- sapply(seq_len(ncol(out$labelmat.mrtree)), function(i) {
  AMRI(out$labelmat.mrtree[, i], ref_labels)$amri
})

df <- rbind(
  data.frame(
    k = amri_flat$k,
    amri = amri_flat$x,
    method = "Seurat flat"
  ),
  data.frame(k = ks_mrtree, amri = amri_recon, method = "MRtree")
)
ggplot2::ggplot(data = df, aes(x = k, y = amri, color = method)) +
  geom_line() +
  theme_bw()
```

### Stability

```{r}
#| label = "pl-clustering-resolution",
#| fig.align = "center",
#| fig.width = 4,
#| fig.asp = 0.918
stab_out <- stability_plot(out)
stab_out$plot
```

```{r}
#| label = "select-resolution"
kable_material(
  kable(
    stab_out$df,
    "html"
  ),
  bootstrap_options = c(
    "bordered",
    "condensed",
    "responsive",
    "striped"
  ),
  position = "left",
  font_size = 14
)

res_k <- select_resolution(stab_out$df)

kable_material(
  kable(
    table(
      out$labelmat.mrtree[, which.min(
        abs(as.integer(
          str_remove(dimnames(
            out$labelmat.mrtree
          )[[2]], "K")
        ) - res_k)
      )]
    ),
    "html"
  ),
  bootstrap_options = c(
    "bordered",
    "condensed",
    "responsive",
    "striped"
  ),
  position = "left",
  font_size = 14
)
```

## Selected clustering resolution {.tabset}

### UMAP

```{r}
#| label = "pl-UMAP-clustering",
#| fig.align = "center",
#| fig.width = 9,
#| fig.asp = 0.309
combined_srt$k_tree <- out$labelmat.mrtree[, which.min(
  abs(as.integer(
    str_remove(dimnames(
      out$labelmat.mrtree
    )[[2]], "K")
  ) - res_k)
)] %>%
  as.numeric() %>%
  as.factor()
p1 <-
  DimPlot_scCustom(
    combined_srt,
    pt.size = 1,
    ggplot_default_colors = TRUE,
    color_seed = reseed,
    shuffle = TRUE,
    seed = reseed,
    alpha = 0.5,
    repel = TRUE,
    label = TRUE,
    label.size = 5
  ) + ggtitle("Unsupervised overclustering") + NoLegend()
p2 <-
  DimPlot_scCustom(
    combined_srt,
    group.by = "k_tree",
    pt.size = 1,
    ggplot_default_colors = TRUE,
    color_seed = reseed,
    shuffle = TRUE,
    seed = reseed,
    alpha = 0.5,
    repel = TRUE,
    label = TRUE,
    label.size = 5
  ) + ggtitle("MRTree") + NoLegend()

p1 | p2
```

### PaCMAP

```{r}
#| label = "pl-PaCMAP-clustering",
#| fig.align = "center",
#| fig.width = 9,
#| fig.asp = 0.309
p1 <-
  DimPlot_scCustom(
    combined_srt,
    pt.size = 1,
    ggplot_default_colors = TRUE,
    color_seed = reseed,
    reduction = "pacmap",
    shuffle = TRUE,
    seed = reseed,
    alpha = 0.5,
    repel = TRUE,
    label = TRUE,
    label.size = 5
  ) + ggtitle("Unsupervised overclustering") + NoLegend()
p2 <-
  DimPlot_scCustom(
    combined_srt,
    group.by = "k_tree",
    pt.size = 1,
    ggplot_default_colors = TRUE,
    color_seed = reseed,
    reduction = "pacmap",
    shuffle = TRUE,
    seed = reseed,
    alpha = 0.5,
    repel = TRUE,
    label = TRUE,
    label.size = 5
  ) + ggtitle("MRTree") + NoLegend()

p1 | p2
```

### tSNE

```{r}
#| label = "pl-tSNE-clustering",
#| fig.align = "center",
#| fig.width = 9,
#| fig.asp = 0.309
p1 <-
  DimPlot_scCustom(
    combined_srt,
    pt.size = 1,
    ggplot_default_colors = TRUE,
    color_seed = reseed,
    reduction = "tsne",
    shuffle = TRUE,
    seed = reseed,
    alpha = 0.5,
    repel = TRUE,
    label = TRUE,
    label.size = 5
  ) + ggtitle("Unsupervised overclustering") + NoLegend()
p2 <-
  DimPlot_scCustom(
    combined_srt,
    group.by = "k_tree",
    pt.size = 1,
    ggplot_default_colors = TRUE,
    color_seed = reseed,
    reduction = "tsne",
    shuffle = TRUE,
    seed = reseed,
    alpha = 0.5,
    repel = TRUE,
    label = TRUE,
    label.size = 5
  ) + ggtitle("MRTree") + NoLegend()

p1 | p2
```

## tdTomato across clusters

```{r}
#| label = "plt-tdTomato-vln",
#| fig.width = 5,
#| fig.asp = 0.618
VlnPlot_scCustom(seurat_object = combined_srt, assay = "RNA", layer = "counts", features = c("tdTomato"), plot_median = TRUE) & NoLegend()
```

## UMAP plot of gene expression {.tabset}

```{r}
#| label = "expression",
#| results = "hide"
src_list <- map(genes.embed, function(gene) {
  src <- c(
    "### {{gene}} {.unnumbered}",
    "```{r pl-umap-expression-{{gene}}}",
    "FeaturePlot_scCustom(",
    "seurat_object = combined_srt, features = '{{gene}}',",
    "pt.size = 1, order = TRUE,",
    "colors_use = combined_srt@misc$expr_Colour_Pal,",
    "alpha_na_exp = 0.1, alpha_exp = 0.45) +",
    "ggtitle(sprintf('%s: ', '{{gene}}')) +",
    "theme(plot.title = element_text(size = 24))",
    "```",
    ""
  )
  knitr::knit_expand(text = src)
})

out <- knitr::knit_child(text = unlist(src_list), options = list(cache = FALSE))
```

`r out`

## Dot-plot of gene expression {.tabset}

### Transcription Factors {.tabset}

```{r}
#| label = "tf"
plt_g_tf <- transcription_factors %>% .[. %in% hvg]
```

#### SCT

```{r}
#| label = "pl-tf-dotplot-sct",
#| fig.height = 58,
#| fig.width = 16
DotPlot_scCustom(
  seurat_object = combined_srt,
  assay = "SCT",
  features = plt_g_tf,
  flip_axes = TRUE,
  x_lab_rotate = TRUE,
  colors_use = viridis(n = 30, alpha = .55, direction = -1, option = "G")
)
```

#### RNA

```{r}
#| label = "pl-tf-dotplot-rna",
#| fig.height = 58,
#| fig.width = 16
DotPlot_scCustom(
  seurat_object = combined_srt,
  assay = "RNA",
  features = plt_g_tf,
  flip_axes = TRUE,
  x_lab_rotate = TRUE,
  colors_use = viridis(n = 30, alpha = .55, direction = -1, option = "E")
)
```

### Glutamate {.tabset}

```{r}
#| label = "glut"
plt_g_glut <- c(glut, glutr) %>% .[. %in% hvg]
```

#### SCT

```{r}
#| label = "pl-glut-dotplot-sct",
#| fig.asp = 0.618,
#| fig.width = 16
DotPlot_scCustom(
  seurat_object = combined_srt,
  assay = "SCT",
  features = plt_g_glut,
  flip_axes = TRUE,
  x_lab_rotate = TRUE,
  colors_use = viridis(n = 30, alpha = .55, direction = -1, option = "G")
)
```

#### RNA

```{r}
#| label = "pl-glut-dotplot-rna",
#| fig.asp = 0.618,
#| fig.width = 16
DotPlot_scCustom(
  seurat_object = combined_srt,
  assay = "RNA",
  features = plt_g_glut,
  flip_axes = TRUE,
  x_lab_rotate = TRUE,
  colors_use = viridis(n = 30, alpha = .55, direction = -1, option = "E")
)
```

### GABA {.tabset}

```{r}
#| label = "gaba"
plt_g_gaba <- c(gaba, gabar) %>% .[. %in% hvg]
```

#### SCT

```{r}
#| label = "pl-gaba-dotplot-sct",
#| fig.asp = 0.618,
#| fig.width = 16
DotPlot_scCustom(
  seurat_object = combined_srt,
  assay = "SCT",
  features = unique(plt_g_gaba),
  flip_axes = TRUE,
  x_lab_rotate = TRUE,
  colors_use = viridis(n = 30, alpha = .55, direction = -1, option = "G")
)
```

#### RNA

```{r}
#| label = "pl-gaba-dotplot-rna",
#| fig.asp = 0.618,
#| fig.width = 16
DotPlot_scCustom(
  seurat_object = combined_srt,
  assay = "RNA",
  features = unique(plt_g_gaba),
  flip_axes = TRUE,
  x_lab_rotate = TRUE,
  colors_use = viridis(n = 30, alpha = .55, direction = -1, option = "E")
)
```

### Neuropeptides {.tabset}

```{r}
#| label = "np"
plt_g_np <- c(np) %>% .[. %in% hvg]
```

#### SCT

```{r}
#| label = "pl-np-dotplot-sct",
#| fig.height = 3.5,
#| fig.width = 16
DotPlot_scCustom(
  seurat_object = combined_srt,
  assay = "SCT",
  features = unique(plt_g_np),
  flip_axes = TRUE,
  x_lab_rotate = TRUE,
  colors_use = viridis(n = 30, alpha = .55, direction = -1, option = "G")
)
```

#### RNA

```{r}
#| label = "pl-np-dotplot-rna",
#| fig.height = 3.5,
#| fig.width = 16
DotPlot_scCustom(
  seurat_object = combined_srt,
  assay = "RNA",
  features = unique(plt_g_np),
  flip_axes = TRUE,
  x_lab_rotate = TRUE,
  colors_use = viridis(n = 30, alpha = .55, direction = -1, option = "E")
)
```

### Neuropeptide receptors {.tabset}

```{r}
#| label = "npr"
plt_g_npr <- c(npr) %>% .[. %in% hvg]
```

#### SCT

```{r}
#| label = "pl-npr-dotplot-sct",
#| fig.height = 5.5,
#| fig.width = 16
DotPlot_scCustom(
  seurat_object = combined_srt,
  assay = "SCT",
  features = unique(plt_g_npr),
  flip_axes = TRUE,
  x_lab_rotate = TRUE,
  colors_use = viridis(n = 30, alpha = .55, direction = -1, option = "G")
)
```

#### RNA

```{r}
#| label = "pl-npr-dotplot-rna",
#| fig.height = 5.5,
#| fig.width = 16
DotPlot_scCustom(
  seurat_object = combined_srt,
  assay = "RNA",
  features = unique(plt_g_npr),
  flip_axes = TRUE,
  x_lab_rotate = TRUE,
  colors_use = viridis(n = 30, alpha = .55, direction = -1, option = "E")
)
```

### Neuromediators receptors {.tabset}

```{r}
#| label = "nmr"
plt_g_nmr <- c(nmr) %>%
  .[. %in% hvg] %>%
  .[!. %in% c(plt_g_glut, plt_g_gaba)]
```

#### SCT

```{r}
#| label = "pl-nmr-dotplot-sct",
#| fig.asp = 0.618,
#| fig.width = 16
DotPlot_scCustom(
  seurat_object = combined_srt,
  assay = "SCT",
  features = unique(plt_g_nmr),
  flip_axes = TRUE,
  x_lab_rotate = TRUE,
  colors_use = viridis(n = 30, alpha = .55, direction = -1, option = "G")
)
```

#### RNA

```{r}
#| label = "pl-nmr-dotplot-rna",
#| fig.asp = 0.618,
#| fig.width = 16
DotPlot_scCustom(
  seurat_object = combined_srt,
  assay = "RNA",
  features = unique(plt_g_nmr),
  flip_axes = TRUE,
  x_lab_rotate = TRUE,
  colors_use = viridis(n = 30, alpha = .55, direction = -1, option = "E")
)
```

### Cannabinoids {.tabset}

```{r}
#| label = "ecb"
plt_g_ecb <- c(cnbn) %>% .[. %in% hvg]
```

#### SCT

```{r}
#| label = "pl-ecb-dotplot-sct",
#| fig.height = 3.5,
#| fig.width = 16
DotPlot_scCustom(
  seurat_object = combined_srt,
  assay = "SCT",
  features = unique(plt_g_ecb),
  flip_axes = TRUE,
  x_lab_rotate = TRUE,
  colors_use = viridis(n = 30, alpha = .55, direction = -1, option = "G")
)
```

#### RNA

```{r}
#| label = "pl-ecb-dotplot-rna",
#| fig.height = 3.5,
#| fig.width = 16
DotPlot_scCustom(
  seurat_object = combined_srt,
  assay = "RNA",
  features = unique(plt_g_ecb),
  flip_axes = TRUE,
  x_lab_rotate = TRUE,
  colors_use = viridis(n = 30, alpha = .55, direction = -1, option = "E")
)
```

## Differential gene expression (DGE) {.tabset}

We see the spread of our targets across derived clusters, which isn't
optimal. Lets see if we will see some significant hits with proper
statistical testing.

```{r}
#| label = "markers-tables"
plan("sequential")
invisible(gc())
set.seed(reseed)
plan(multicore, workers = n_cores)


Idents(combined_srt) <- "k_tree"
combined_srt <-
  PrepSCTFindMarkers(combined_srt, assay = "SCT")
```

### logistic regression {.tabset}

```{r}
#| label = "markers-logreg"
markers_logreg <-
  FindAllMarkers(
    combined_srt,
    assay = "SCT",
    verbose = FALSE,
    random.seed = reseed,
    only.pos = TRUE,
    min.pct = 0.2,
    base = 10,
    logfc.threshold = 0.2,
    densify = TRUE,
    test.use = "LR"
  )

# markers_logreg %>%
#   pull(gene) %>%
#   gconvert(
#   .,
#   organism = "mmusculus",
#   target = "MGI",
#   numeric_ns = "",
#   mthreshold = Inf,
#   filter_na = TRUE
# ) %>%
#   select(name, description) %>%
#   right_join(markers_logreg, by = c("gene" = "name"))

write_csv(
  markers_logreg,
  here(
    tables_dir,
    docname,
    sprintf(
      "%s_all_mrk-logreg_sct-combined-whole_dataset-fpr_%s.csv",
      project, cb_fpr
    )
  )
)

markers_logreg %>%
  group_by(cluster) %>%
  slice_max(n = 20, order_by = avg_log10FC) %>%
  kable("html") %>%
  kable_material(
    bootstrap_options = c(
      "bordered",
      "condensed",
      "responsive",
      "striped"
    ),
    position = "left",
    font_size = 14
  )
```

```{r}
#| include = FALSE,
#| fig.align = "center",
#| fig.height = 10,
#| fig.width = 10
plan("sequential")
invisible(gc())
set.seed(reseed)
plan(multicore, workers = n_cores)


top5_markers <-
  Extract_Top_Markers(
    marker_dataframe = markers_logreg,
    num_genes = 5,
    named_vector = FALSE,
    make_unique = TRUE,
    rank_by = "avg_log10FC"
  )

pl_clst_dotplot <-
  try(
    {
      Clustered_DotPlot(
        seurat_object = combined_srt,
        features = c("tdTomato", top5_markers),
        k = length(levels(combined_srt)) + 1,
        ggplot_default_colors = TRUE,
        color_seed = reseed,
        seed = reseed
      )
    },
    silent = TRUE
  )


# markers
Iterate_FeaturePlot_scCustom(
  seurat_object = combined_srt,
  gene_list = top5_markers,
  single_pdf = TRUE,
  colors_use = viridis(
    n = 30,
    alpha = .55,
    direction = -1,
    option = "E"
  ),
  pt.size = 3,
  alpha_exp = 0.45,
  alpha_na_exp = 0.1,
  file_path = here(plots_dir),
  file_name = sprintf(
    "/combined-top5_logreg-umap-whole_dataset-fpr_%s",
    cb_fpr
  ),
  file_type = ".pdf"
)
# stress
Iterate_FeaturePlot_scCustom(
  seurat_object = combined_srt,
  gene_list = stress_genes,
  single_pdf = TRUE,
  colors_use = viridis(
    n = 30,
    alpha = .55,
    direction = -1,
    option = "E"
  ),
  pt.size = 3,
  alpha_exp = 0.45,
  alpha_na_exp = 0.1,
  file_path = here(plots_dir),
  file_name = sprintf(
    "/combined-stress-umap-whole_dataset-fpr_%s",
    cb_fpr
  ),
  file_type = ".pdf"
)
# sex
Iterate_FeaturePlot_scCustom(
  seurat_object = combined_srt,
  gene_list = sex_genes,
  single_pdf = TRUE,
  colors_use = viridis(
    n = 30,
    alpha = .55,
    direction = -1,
    option = "E"
  ),
  pt.size = 3,
  alpha_exp = 0.45,
  alpha_na_exp = 0.1,
  file_path = here(plots_dir),
  file_name = sprintf(
    "/combined-sex-umap-whole_dataset-fpr_%s",
    cb_fpr
  ),
  file_type = ".pdf"
)
# tf
Iterate_FeaturePlot_scCustom(
  seurat_object = combined_srt,
  gene_list = plt_g_tf,
  single_pdf = TRUE,
  colors_use = viridis(
    n = 30,
    alpha = .55,
    direction = -1,
    option = "E"
  ),
  pt.size = 3,
  alpha_exp = 0.45,
  alpha_na_exp = 0.1,
  file_path = here(plots_dir),
  file_name = sprintf(
    "/combined-tf-umap-whole_dataset-fpr_%s",
    cb_fpr
  ),
  file_type = ".pdf"
)
# glut
Iterate_FeaturePlot_scCustom(
  seurat_object = combined_srt,
  gene_list = plt_g_glut,
  single_pdf = TRUE,
  colors_use = viridis(
    n = 30,
    alpha = .55,
    direction = -1,
    option = "E"
  ),
  pt.size = 3,
  alpha_exp = 0.45,
  alpha_na_exp = 0.1,
  file_path = here(plots_dir),
  file_name = sprintf(
    "/combined-glut-umap-whole_dataset-fpr_%s",
    cb_fpr
  ),
  file_type = ".pdf"
)
# gaba
Iterate_FeaturePlot_scCustom(
  seurat_object = combined_srt,
  gene_list = plt_g_gaba,
  single_pdf = TRUE,
  colors_use = viridis(
    n = 30,
    alpha = .55,
    direction = -1,
    option = "E"
  ),
  pt.size = 3,
  alpha_exp = 0.45,
  alpha_na_exp = 0.1,
  file_path = here(plots_dir),
  file_name = sprintf(
    "/combined-gaba-umap-whole_dataset-fpr_%s",
    cb_fpr
  ),
  file_type = ".pdf"
)
# nmr
Iterate_FeaturePlot_scCustom(
  seurat_object = combined_srt,
  gene_list = plt_g_nmr,
  single_pdf = TRUE,
  colors_use = viridis(
    n = 30,
    alpha = .55,
    direction = -1,
    option = "E"
  ),
  pt.size = 3,
  alpha_exp = 0.45,
  alpha_na_exp = 0.1,
  file_path = here(plots_dir),
  file_name = sprintf(
    "/combined-nmr-umap-whole_dataset-fpr_%s",
    cb_fpr
  ),
  file_type = ".pdf"
)
# np receptors
Iterate_FeaturePlot_scCustom(
  seurat_object = combined_srt,
  gene_list = npr,
  single_pdf = TRUE,
  colors_use = viridis(
    n = 30,
    alpha = .55,
    direction = -1,
    option = "E"
  ),
  pt.size = 3,
  alpha_exp = 0.45,
  alpha_na_exp = 0.1,
  file_path = here(plots_dir),
  file_name = sprintf(
    "/combined-npr-umap-whole_dataset-fpr_%s",
    cb_fpr
  ),
  file_type = ".pdf"
)
```

#### Dot-plot

```{r}
#| label = "pl-clst-dotplot-logreg",
#| echo = FALSE,
#| fig.align = "center",
#| fig.height = 14,
#| fig.width = 10
if (class(pl_clst_dotplot) != "try-error") pl_clst_dotplot[[2]]
```

#### Heatmap

```{r}
#| label = "pl-heatmap-logreg",
#| fig.width = 18,
#| fig.asp = 1.33
top10 <-
  markers_logreg %>%
  group_by(cluster) %>%
  top_n(n = 10, wt = avg_log10FC)
DoHeatmap(combined_srt, features = top10$gene) + NoLegend()
```

### MAST {.tabset}

```{r}
#| label = "markers-MAST"
plan("sequential")
invisible(gc())
set.seed(reseed)
plan(multicore, workers = n_cores)


markers_MAST <-
  FindAllMarkers(
    combined_srt,
    assay = "SCT",
    verbose = FALSE,
    random.seed = reseed,
    only.pos = TRUE,
    min.pct = 0.1,
    base = 10,
    logfc.threshold = 0.2,
    test.use = "MAST"
  )

# markers_MAST %>%
#   pull(gene) %>%
#   gconvert(
#   .,
#   organism = "mmusculus",
#   target = "MGI",
#   numeric_ns = "",
#   mthreshold = Inf,
#   filter_na = TRUE
# ) %>%
#   select(name, description) %>%
#   right_join(markers_MAST, by = c("gene" = "name"))

write_csv(
  markers_MAST,
  here(
    tables_dir,
    docname,
    sprintf(
      "%s_all_mrk-MAST_sct-combined-whole_dataset-fpr_%s.csv",
      project, cb_fpr
    )
  )
)
markers_MAST %>%
  group_by(cluster) %>%
  slice_max(n = 20, order_by = avg_log10FC) %>%
  kable("html") %>%
  kable_material(
    bootstrap_options = c(
      "bordered",
      "condensed",
      "responsive",
      "striped"
    ),
    position = "left",
    font_size = 14
  )
```

```{r}
#| include = FALSE,
#| fig.align = "center",
#| fig.height = 18,
#| fig.width = 10
plan("sequential")
invisible(gc())
set.seed(reseed)
plan(multicore, workers = n_cores)


top5_markers <-
  Extract_Top_Markers(
    marker_dataframe = markers_MAST,
    num_genes = 5,
    named_vector = FALSE,
    make_unique = TRUE,
    rank_by = "avg_log10FC"
  )

pl_clst_dotplot <-
  try(
    {
      Clustered_DotPlot(
        seurat_object = combined_srt,
        features = c(top5_markers),
        k = length(levels(combined_srt)) + 1,
        ggplot_default_colors = TRUE,
        color_seed = reseed,
        seed = reseed
      )
    },
    silent = TRUE
  )

# markers
Iterate_FeaturePlot_scCustom(
  seurat_object = combined_srt,
  gene_list = top5_markers,
  single_pdf = TRUE,
  colors_use = viridis(
    n = 30,
    alpha = .55,
    direction = -1,
    option = "E"
  ),
  pt.size = 3,
  alpha_exp = 0.45,
  alpha_na_exp = 0.1,
  file_path = here(plots_dir),
  file_name = sprintf(
    "/combined-top5_MAST-umap-whole_dataset-fpr_%s",
    cb_fpr
  ),
  file_type = ".pdf"
)
```

#### Dot-plot

```{r}
#| label = "pl-clst-dotplot-MAST",
#| echo = FALSE,
#| fig.align = "center",
#| fig.height = 18,
#| fig.width = 10
if (class(pl_clst_dotplot) != "try-error") pl_clst_dotplot[[2]]
```

#### Heatmap

```{r}
#| label = "pl-heatmap-MAST",
#| fig.width = 18,
#| fig.asp = 1.33
top10 <-
  markers_MAST %>%
  group_by(cluster) %>%
  top_n(n = 10, wt = avg_log10FC)
DoHeatmap(combined_srt, features = top10$gene) + NoLegend()
```

# Transfer tdTomato cells onto reference 

```{r}
#| label = "prepare-reference"
# Run PCA
merged_cortex <- RunPCA(merged_cortex, npcs = 20, verbose = FALSE)

# Set cell type annotations as identities if available
Idents(merged_cortex) <- "New_cellType"

ElbowPlot(merged_cortex, ndims = 20)
```

```{r}
#| label = "umap-ref"
invisible(gc())
set.seed(reseed)
# registerDoParallel(cores = availableCores())

selected_pcs <-
  seq_len(20)

if (!file.exists(here(data_dir, glue::glue("{project}-init/{project}-init-umap-search-ref.Rds")))) {
  umap_example <- scDEED(
    input_data = merged_cortex,
    K = 20,
    n_neighbors = seq(from = 15, to = 55, by = 20),
    min.dist = c(0.01, 0.05, 0.1, 0.25, 0.5, 0.8),
    reduction.method = "umap",
    default_assay = "RNA"
  )

  dir.create(here(data_dir, sprintf("%s-init", project)))
  readr::write_rds(
    x = umap_example,
    file = here(data_dir, glue::glue("{project}-init/{project}-init-umap-search-ref.Rds"))
  )
} else {
  umap_example <-
    read_rds(here(data_dir, glue::glue("{project}-init/{project}-init-umap-search-ref.Rds")))
}
```

```{r}
#| label = "pl-unsupervised-ref"
invisible(gc())
set.seed(seed = reseed)

merged_cortex <-
  merged_cortex |>
  FindNeighbors(
    dims = selected_pcs,
    k.param = umap_example$num_dubious |>
      dplyr::slice_min(
        order_by = c(number_dubious_cells),
        n = 1
      ) |>
      dplyr::slice_min(
        order_by = c(min.dist),
        n = 1
      ) |>
      pull(n_neighbors),
    annoy.metric = "euclidean",
    n.trees = 100,
    verbose = FALSE
  )

merged_cortex <-
  merged_cortex |>
  RunUMAP(
    dims = selected_pcs,
    reduction.name = "umap",
    reduction.key = "UMAP_",
    return.model = TRUE,
    n.epochs = 1000L,
    n.neighbors = umap_example$num_dubious |>
      dplyr::slice_min(
        order_by = c(number_dubious_cells),
        n = 1
      ) |>
      dplyr::slice_min(
        order_by = c(min.dist),
        n = 1
      ) |>
      pull(n_neighbors),
    min.dist = umap_example$num_dubious |>
      dplyr::slice_min(
        order_by = c(number_dubious_cells),
        n = 1
      ) |>
      dplyr::slice_min(
        order_by = c(min.dist),
        n = 1
      ) |>
      pull(min.dist),
    seed.use = reseed,
    verbose = FALSE
  )
```

```{r}
#| label = "prepare-for-query"
DefaultAssay(combined_srt) <- "RNA"

# Normalize the data
combined_srt <- NormalizeData(combined_srt, verbose = FALSE)

# Identify variable features
combined_srt <- FindVariableFeatures(combined_srt, selection.method = "vst", nfeatures = 5000, verbose = FALSE)

# Scale the data
combined_srt <- ScaleData(combined_srt, features = keep_genes, verbose = FALSE)
```

```{r}
#| label = "transfer-query"
# Find transfer anchors
anchors <- FindTransferAnchors(
  reference = merged_cortex,
  query = combined_srt,
  dims = selected_pcs,
  reference.reduction = "pca"
)

# Map the query data onto the reference UMAP and transfer cell type annotations
combined_srt <- MapQuery(
  anchorset = anchors,
  reference = merged_cortex,
  query = combined_srt,
  refdata = list(New_cellType = "New_cellType"), # Transfer cell type labels
  reference.reduction = "pca",
  reduction.model = "umap"
)

# The predicted cell types are stored in combined_srt$predicted.New_cellType
# The projected UMAP coordinates are in combined_srt[["ref.umap"]]
```

```{r}
#| label = "plot-types-all-cells-with-query",
#| fig.height = 9,
#| fig.width = 23
# Plot the reference UMAP colored by cell types
p1 <- DimPlot_scCustom(
  seurat_object = merged_cortex,
  reduction = "umap",
  group.by = "New_cellType",
  pt.size = 1,
  colors_use = merged_cortex@misc$types_Colour_Pal,
  shuffle = TRUE,
  seed = reseed,
  alpha = 0.5,
  repel = TRUE,
  label = TRUE,
  label.size = 5
) + ggtitle("Reference: Cell Type Annotations")

# Plot the query cells projected onto the reference UMAP, colored by the predicted cell types
p2 <- DimPlot_scCustom(
  seurat_object = combined_srt,
  reduction = "ref.umap",
  group.by = "predicted.New_cellType",
  pt.size = 1,
  colors_use = merged_cortex@misc$types_Colour_Pal,
  shuffle = TRUE,
  seed = reseed,
  alpha = 0.5,
  repel = TRUE,
  label = TRUE,
  label.size = 5
) + NoLegend() + ggtitle("Query: Transferred Cell Type Labels")

# Combine the plots
p1 + p2 + plot_layout(guides = "collect")
```

```{r}
#| label = "plot-Scgn-reference-by-days",
#| fig.height = 18,
#| fig.width = 60
# Plot the projected UMAP, coloring by Scgn expression
FeaturePlot_scCustom(
  seurat_object = merged_cortex,
  features = c("Scgn"),
  reduction = "umap",
  split.by = "stage",
  pt.size = 2,
  alpha_exp = 0.5,
  repel = TRUE,
  label = TRUE,
  label.size = 5,
  num_columns = 6
)
```

```{r}
#| label = "plot-query-tdTomato",
#| fig.height = 9,
#| fig.width = 21
# Plot the projected UMAP, coloring by tdTomato status
DimPlot(
  combined_srt,
  reduction = "ref.umap",
  group.by = "predicted.New_cellType",
  split.by = "Scgn_tdTomato",
  pt.size = 1,
  cols = merged_cortex@misc$types_Colour_Pal,
  shuffle = TRUE,
  seed = reseed,
  alpha = 0.5,
  repel = TRUE,
  label = TRUE,
  label.size = 5
) + ggtitle("tdTomato Status in Query Cells")
```

```{r}
#| label = "plot-Scgn-query-tdTomato",
#| fig.height = 9,
#| fig.width = 20
# Plot the projected UMAP, coloring by tdTomato status
DimPlot_scCustom(
  seurat_object = combined_srt,
  reduction = "ref.umap",
  group.by = "k_tree",
  split.by = "Scgn_tdTomato",
  pt.size = 1,
  colors_use = merged_cortex@misc$types_Colour_Pal,
  shuffle = TRUE,
  seed = reseed,
  alpha = 0.5,
  repel = TRUE,
  label = TRUE,
  label.size = 5
) + ggtitle("tdTomato Status in Query Cells")

subset(combined_srt, subset = Scgn_tdTomato == "Scgn_Cre")$predicted.New_cellType |> table()

subset(combined_srt, subset = Scgn_tdTomato == "Scgn_Cre")$k_tree |> table()
```

```{r}
#| label = "plot-stacked-vln-markers-query-by-Scgn",
#| fig.height = 38,
#| fig.width = 20
sample_colors <- c("dodgerblue", "firebrick1")
names(sample_colors) <- c("WT", "Scgn_Cre")
Idents(combined_srt) <- "predicted.New_cellType"
migneuro_cre <- FindMarkers(subset(
    combined_srt,
    idents = c(
      "Migrating neurons")),
    ident.1 = "Scgn_Cre",
    ident.2 = "WT",
    group.by = "Scgn_tdTomato",
    assay = "SCT",
    verbose = FALSE,
    random.seed = reseed,
    only.pos = TRUE,
    min.pct = 0.2,
    base = 10,
    logfc.threshold = 0.2,
    densify = TRUE,
    test.use = "LR"
)

astro_cre <- FindMarkers(subset(
    combined_srt,
    idents = c(
      "Astrocytes")),
    ident.1 = "Scgn_Cre",
    ident.2 = "WT",
    group.by = "Scgn_tdTomato",
    assay = "SCT",
    verbose = FALSE,
    random.seed = reseed,
    only.pos = TRUE,
    min.pct = 0.2,
    base = 10,
    logfc.threshold = 0.2,
    densify = TRUE,
    test.use = "LR"
)

oligo_cre <- FindMarkers(subset(
    combined_srt,
    idents = c(
      "Oligodendrocytes")),
    ident.1 = "Scgn_Cre",
    ident.2 = "WT",
    group.by = "Scgn_tdTomato",
    assay = "SCT",
    verbose = FALSE,
    random.seed = reseed,
    only.pos = TRUE,
    min.pct = 0.2,
    base = 10,
    logfc.threshold = 0.2,
    densify = TRUE,
    test.use = "LR"
)

cthpn_cre <- FindMarkers(subset(
    combined_srt,
    idents = c(
      "CThPN")),
    ident.1 = "Scgn_Cre",
    ident.2 = "WT",
    group.by = "Scgn_tdTomato",
    assay = "SCT",
    verbose = FALSE,
    random.seed = reseed,
    only.pos = TRUE,
    min.pct = 0.2,
    base = 10,
    logfc.threshold = 0.2,
    densify = TRUE,
    test.use = "LR"
)

# Create Plots
Stacked_VlnPlot(
  seurat_object = subset(
    combined_srt,
    idents = c(
      "Astrocytes",
      "Oligodendrocytes",
      "CThPN",
      "Migrating neurons")), 
  features = c(
    markers_logreg %>%
      dplyr::filter(cluster %in% c(
        subset(
          combined_srt,
          subset = Scgn_tdTomato == "Scgn_Cre")$k_tree |> 
          droplevels() |> 
          table() %>% .[. > 1] |> names()
        )) |> 
      group_by(cluster) %>%
      top_n(n = 2, wt = avg_log10FC) |> 
      pull(gene),
    migneuro_cre |> 
      dplyr::filter(pct.1 > 0.5, p_val < 0.001) |>
      top_n(n = 3, wt = avg_log10FC) |>
      rownames(),
    astro_cre |> 
      dplyr::filter(pct.1 > 0.5, p_val < 0.001) |>
      top_n(n = 3, wt = avg_log10FC) |>
      rownames(),
    oligo_cre |> 
      dplyr::filter(pct.1 > 0.5, p_val < 0.001) |>
      top_n(n = 3, wt = avg_log10FC) |>
      rownames(),
    cthpn_cre |> 
      dplyr::filter(pct.1 > 0.5, p_val < 0.001) |>
      top_n(n = 3, wt = avg_log10FC) |>
      rownames(), 
    "tdTomato"
  ),
  x_lab_rotate = TRUE,
  colors_use = sample_colors,
  group.by = "predicted.New_cellType",
  split.by = "Scgn_tdTomato")
```

```{r}
#| label = "plot-markers-query-by-Scgn",
#| fig.height = 8,
#| fig.width = 7

neurotrans <- Feature_Present(
  subset(
    combined_srt,
    idents = c(
      "Astrocytes",
      "Oligodendrocytes",
      "CThPN",
      "Migrating neurons")),
  features = neurotrans)

# Create Plots
Clustered_DotPlot(
  subset(
    combined_srt,
    idents = c(
      "Astrocytes",
      "Oligodendrocytes",
      "CThPN",
      "Migrating neurons")),
  features = c(
    markers_logreg %>%
      dplyr::filter(cluster %in% c(
        subset(
          combined_srt,
          subset = Scgn_tdTomato == "Scgn_Cre")$k_tree |> 
          droplevels() |> 
          table() %>% .[. > 1] |> names()
        )) |> 
      group_by(cluster) %>%
      top_n(n = 3, wt = avg_log10FC) |> 
      pull(gene),
    migneuro_cre |> 
      dplyr::filter(pct.1 > 0.5, p_val < 0.001) |>
      top_n(n = 3, wt = avg_log10FC) |>
      rownames(),
    astro_cre |> 
      dplyr::filter(pct.1 > 0.5, p_val < 0.001) |>
      top_n(n = 3, wt = avg_log10FC) |>
      rownames(),
    oligo_cre |> 
      dplyr::filter(pct.1 > 0.5, p_val < 0.001) |>
      top_n(n = 3, wt = avg_log10FC) |>
      rownames(),
    cthpn_cre |> 
      dplyr::filter(pct.1 > 0.5, p_val < 0.001) |>
      top_n(n = 3, wt = avg_log10FC) |>
      rownames(), 
    "tdTomato",
    "Gad1", "Slc32a1", "Slc17a6", "Glul"
    ),
  group.by = "predicted.New_cellType",
  split.by = "Scgn_tdTomato",
  plot_padding = TRUE
  )
```


```{r}
#| label = "plot-cycling-markers-query-by-Scgn",
#| fig.height = 146,
#| fig.width = 20
# Plot the projected UMAP, coloring by Scgn expression
FeaturePlot_scCustom(
  seurat_object = combined_srt,
  features = c(
    migneuro_cre |> 
      dplyr::filter(pct.1 > 0.5, p_val < 0.001) |>
      top_n(n = 3, wt = avg_log10FC) |>
      rownames(),
    astro_cre |> 
      dplyr::filter(pct.1 > 0.5, p_val < 0.0001) |>
      top_n(n = 3, wt = avg_log10FC) |>
      rownames(),
    oligo_cre |> 
      dplyr::filter(pct.1 > 0.5, p_val < 0.001) |>
      top_n(n = 3, wt = avg_log10FC) |>
      rownames(),
    cthpn_cre |> 
      dplyr::filter(pct.1 > 0.5, p_val < 0.001) |>
      top_n(n = 3, wt = avg_log10FC) |>
      rownames(),
    "Gad1", "Slc32a1", "Slc17a6", "Glul"
  ),
  reduction = "ref.umap",
  split.by = "Scgn_tdTomato",
  pt.size = 2,
  alpha_exp = 0.5,
  repel = TRUE,
  label = TRUE,
  label.size = 5,
  num_columns = 2
)
```

It seems from these data that majority of Scgn expressing cells became astrocytes.

# Summary

## Parameters

This table describes parameters used and set in this document.

```{r}
#| label = "parameters"
params <- list(
  list(
    Parameter = "high_cutoff_umis",
    Value = high_cutoff_umis,
    Description = "Maximum threshold for total counts"
  ),
  list(
    Parameter = "low_cutoff_gene",
    Value = low_cutoff_gene,
    Description = "Minimum threshold for total features"
  ),
  list(
    Parameter = "high_cutoff_gene",
    Value = high_cutoff_gene,
    Description = "Maximum threshold for total features"
  ),
  list(
    Parameter = "high_cutoff_pc_mt",
    Value = high_cutoff_pc_mt,
    Description = "Maximum threshold for percentage counts mitochondrial"
  ),
  list(
    Parameter = "high_cutoff_pc_ribo",
    Value = high_cutoff_pc_ribo,
    Description = "Maximum threshold for percentage counts ribosomal"
  ),
  list(
    Parameter = "high_cutoff_pc_hb",
    Value = high_cutoff_pc_hb,
    Description = "Maximum threshold for percentage counts hemoglobin"
  ),
  list(
    Parameter = "high_cutoff_complexity",
    Value = high_cutoff_complexity,
    Description = "Maximum threshold for cells complexity"
  ),
  list(
    Parameter = "n_cells",
    Value = ncol(combined_srt),
    Description = "Number of cells in the filtered dataset"
  ),
  list(
    Parameter = "n_genes",
    Value = nrow(combined_srt),
    Description = "Number of genes in the filtered dataset"
  ),
  list(
    Parameter = "median_genes",
    Value = median(Matrix::colSums(GetAssayData(
      combined_srt,
      slot = "counts", assay = "RNA"
    ) != 0)),
    Description = paste(
      "Median number of expressed genes per cell in the",
      "filtered dataset"
    )
  ),
  list(
    Parameter = "median_counts",
    Value = median(Matrix::colSums(GetAssayData(
      combined_srt,
      slot = "counts", assay = "RNA"
    ))),
    Description = paste(
      "Median number of counts per cell in the filtered",
      "dataset"
    )
  ),
  unlist(purrr::map(srr_set, n_cells_per_file))
)
params <- jsonlite::toJSON(params, pretty = TRUE)
knitr::kable(jsonlite::fromJSON(params))
```

## Output files

This table describes the output files produced by this document. Right
click and *Save Link As...* to download the results.

```{r}
#| label = "save-dataset"
saveRDS(
  object = combined_srt,
  file = here(data_dir, sprintf("%s-whole_dataset-fpr_%s-clusters.Rds", project, cb_fpr))
)
```

```{r}
#| label = "output-cells",
#| results = "hide"
dir.create(here(tables_dir, docname), showWarnings = FALSE)
for (sample in unique(combined_srt@meta.data$Scgn_tdTomato)) {
  cells <- combined_srt@meta.data %>%
    as.data.frame() %>%
    filter(Scgn_tdTomato == sample) %>%
    select(cell_name)

  readr::write_tsv(cells,
    print(here(
      tables_dir, docname,
      glue::glue("cell_names-{sample}.tsv")
    )),
    col_names = FALSE
  )
}
```

```{r}
#| label = "output"
readr::write_lines(params, here(tables_dir, docname, "parameters.json"))
knitr::kable(data.frame(
  File = c(
    get_download_link("parameters.json", here(tables_dir, docname)),
    purrr::map_chr(
      srr_set,
      ~ get_download_link(
        file = sprintf("cell_names-%s.tsv", .x),
        folder = here(tables_dir, docname)
      )
    ),
    get_download_link(sprintf(
      "%s_all_mrk-logreg_sct-combined-whole_dataset-fpr_%s.csv",
      project, cb_fpr
    ), here(tables_dir, docname)),
    get_download_link(sprintf(
      "%s_all_mrk-MAST_sct-combined-whole_dataset-fpr_%s.csv",
      project, cb_fpr
    ), here(tables_dir, docname)),
    get_download_link(sprintf(
      "combined-top5_logreg-umap-whole_dataset-fpr_%s.pdf",
      cb_fpr
    ), plots_dir),
    get_download_link(sprintf(
      "combined-top5_MAST-umap-whole_dataset-fpr_%s.pdf",
      cb_fpr
    ), plots_dir)
  ),
  Description = c(
    "Parameters set and used in this analysis",
    purrr::map_chr(srr_set, ~ sprintf("cell_names-%s.tsv", .x)),
    "DGE with logreg test",
    "DGE with MAST test",
    "UMAP embeddings of top5 genes per cluster from logreg test",
    "UMAP embeddings of top5 genes per cluster from MAST test"
  )
))
```

## Session information

```{r}
#| label = "session-info",
#| cache = FALSE
devtools::session_info()
```
